<!DOCTYPE html>
<html>    
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Extending Syntax in Scala</title>
  <meta name="description" content="Yesterday I learned something really cool. In Idris I can just do thisto extend the syntax:">

  <link rel="stylesheet" href="/public/css/main.css">
  <link rel="canonical" href="http://typedops.github.io/tutorials/2015/11/05/extending-syntax.html">
  <link rel="alternate" type="application/atom+xml" title="TypedOps" href="http://typedops.github.io/feed.xml" />
</head>


  <body>
    <header class="header">
	<div class="header-container">
		<div class="nav">
			
				<li>
					<a href="/index.html">home</a>
				</li>
			
			
				<li>
					<a href="/archive.html">archive</a>
				</li>
			
			
				<li>
					<a href="/category.html">category</a>
				</li>
			
			
				<li>
					<a href="/tag.html">tag</a>
				</li>
      
		</div>
		<div class="description"> Better infrastructure through types </div>
		<ul class="social-links">
			<li>
				<a href="https://github.com/mbbx6spp" title="Github">
					<img width="19px" height="19px" src="/public/images/github.png"/>
				</a>
			</li>
			<li>
				<a href="/feed.xml" title="RSS">
					<img width="19px" height="19px" src="/public/images/rss.png"/>
				</a>
			</li>
			<li>
				<a href="https://twitter.com/SusanPotter" title="Twitter">
					<img width="19px" height="19px" src="/public/images/twitter.png"/>
				</a>
			</li>
		</ul>
	</div>
</header>

    <br>
    <div class="page-content">
      <div class="wrapper">
        <article class="single row gutters">
  <time class="published" datetime="2015-11-05">05 November 2015</time>
  <h2>Extending Syntax in Scala</h2>

  <p>Yesterday I learned something really cool. In Idris I can just do this<br />
to extend the syntax:</p>

<pre><code class="language-idris">syntax [ma] "?" [a] = fromMaybe a ma
</code></pre>

<p>where <code>fromMaybe</code> is from the <code>Prelude.Maybe</code> module which has the type<br />
signature: <code>fromMaybe : Lazy a -&gt; Maybe a -&gt; a</code> so now I can do:</p>

<pre><code class="language-idris">idris&gt; (Just 88) ? 77
88 : Integer

idris&gt; Nothing ? 77
77 : Integer
</code></pre>

<p>So today we will see how much of a challenge it will be to do this in Scala.</p>

<p><em>Hint: It might be a little more work, but doable.</em></p>

<h2 id="setup">Setup</h2>

<p>We will start out defining the sum type <code>Maybe</code> with data constructors <code>Nowt</code><br />
(same as <code>Nothing</code> in Idris) and <code>Just</code> which wraps an underlying <code>A</code> value.</p>

<pre><code class="language-scala">scala&gt; sealed abstract class Maybe[A]
defined class Maybe

scala&gt; case class Just[A](a: A) extends Maybe[A]
defined class Just

scala&gt; case class Nowt[A]() extends Maybe[A]
defined class Nowt
</code></pre>

<p>Now we just have to define the <code>fromMaybe[A]</code> decorator. We can do this in the<br />
companion object:</p>

<pre><code class="language-scala">scala&gt; object Maybe {
     |   def fromMaybe[A](a: A)(ma: Maybe[A]): A = ma match {
     |     case Just(x) =&gt; x
     |     case Nowt() =&gt; a
     |   }
     | }
defined object Maybe
warning: previously defined class Maybe is not a companion to object Maybe.
Companions must be defined together; you may wish to use :paste mode for this.
</code></pre>

<p>Now we have what was already provided by Idris in the Prelude, therefore so<br />
far, we have been setting up our Scala code to mimick what we had in Idris.<br />
(Note: we could have also used <code>Option[A]</code> and related <code>getOrElse</code> method<br />
instead of the above).</p>

<pre><code class="language-scala">scala&gt; object Maybe { self =&gt; /* Note: newly added reference to outer object */
     |   def fromMaybe[A](a: A)(ma: Maybe[A]): A = ma match {
     |     case Just(x) =&gt; x
     |     case Nowt() =&gt; a
     |   }
     | 
     |   /* Helpers for value construction */
     |   def apply[A](a: A): Maybe[A] = if (a == null) Nowt() else Just(a)
     |   def nowt[A]: Maybe[A] = Nowt()
     |   def just[A](a: A) = Maybe(a)
     | 
     |   /* Newly added code */
     |   implicit class MaybeOps[A](val ma: Maybe[A]) extends AnyVal {
     |     def ?(a: A): A = self.fromMaybe(a)(ma)
     |   }
     | }
defined object Maybe
warning: previously defined class Maybe is not a companion to object Maybe.
Companions must be defined together; you may wish to use :paste mode for this.
</code></pre>

<p>Now we can test that we can use the new syntax (<code>?</code> operator) the way we want:</p>

<pre><code class="language-scala">scala&gt; object Main extends App {
     |   import Maybe._
     | 
     |   val mint1 = just(30)
     |   val mint2 = nowt[Int]
     | 
     |   println(mint1 ? 60)
     |   println(mint2 ? 60)
     | }
defined object Main

scala&gt; Main.main(Array.empty[String])
30
60
</code></pre>

<p>We added decoration method <code>?</code> to <code>Maybe[A]</code> values by importing the companion<br />
object implicit value class <code>MaybeOps[A]</code> definition into scope.</p>

<p>To recap we only need to add the following code to <em>provide</em> the syntax<br />
within the companion object:</p>

<pre><code class="language-scala">  implicit class MaybeOps[A](val ma: Maybe[A]) extends AnyVal {
    def ?(a: A): A = self.fromMaybe(a)(ma)
  }
</code></pre>

<p>On the consuming side we just need to import the top-level companion object<br />
content into scope like so:</p>

<pre><code class="language-scala">  import Maybe._
</code></pre>

<p>For bonus points, we added a couple of smart value constructors in the<br />
companion object:</p>

<pre><code class="language-scala">scala&gt;   def apply[A](a: A): Maybe[A] = if (a == null) Nowt() else Just(a)
apply: [A](a: A)Maybe[A]

scala&gt;   def nowt[A]: Maybe[A] = Nowt()
nowt: [A]=&gt; Maybe[A]

scala&gt;   def just[A](a: A) = Maybe(a)
just: [A](a: A)Maybe[A]
</code></pre>

<p>This makes consuming code for constructing <code>Maybe[A]</code> values simpler<br />
with appropriate type inference (i.e. we want <code>Maybe[A]</code> to always<br />
be inferred not <code>Just[A]</code> or <code>Nowt[A]</code>).</p>

<p>If we had not added these value constructors or not used them we<br />
would have this problem on our hands:</p>

<pre><code class="language-scala">scala&gt;   val mint1 = Just(30)
mint1: Just[Int] = Just(30)

scala&gt;   val mint2 = Nowt[Int]
mint2: Nowt[Int] = Nowt()
</code></pre>

<p>Look at the types inferred by Scala. In some scenarios, this might<br />
give you problems.</p>

<h2 id="review">Review</h2>

<p>Scala provides a way to extend syntax in a few different ways. Above we<br />
showed one way where we can still uphold the level of typesafety that our API<br />
requires yet still offer some level of syntax/operator decoration or addition.</p>

<p>How could you effectively enhance your operations management libraries with<br />
the technique outlined above?</p>

</article>

      </div>
    </div>
    
    <footer class="footer">
	@2015 Susan Potter.
</footer>

    
  </body>

</html>
