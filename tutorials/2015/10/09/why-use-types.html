<!DOCTYPE html>
<html>    
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Why Use Types?</title>
  <meta name="description" content="Types are one of the most mainstream and widespread applied formal methodsin software engineering industry today. Yet I have met many accomplished andexperie...">

  <link rel="stylesheet" href="/public/css/main.css">
  <link rel="canonical" href="http://typedops.github.io/tutorials/2015/10/09/why-use-types.html">
  <link rel="alternate" type="application/atom+xml" title="TypedOps" href="http://typedops.github.io/feed.xml" />
</head>


  <body>
    <header class="header">
	<div class="header-container">
		<div class="nav">
			
				<li>
					<a href="/index.html">home</a>
				</li>
			
			
				<li>
					<a href="/archive.html">archive</a>
				</li>
			
			
				<li>
					<a href="/category.html">category</a>
				</li>
			
			
				<li>
					<a href="/tag.html">tag</a>
				</li>
      
		</div>
		<div class="description"> Better infrastructure through types </div>
		<ul class="social-links">
			<li>
				<a href="https://github.com/mbbx6spp" title="Github">
					<img width="19px" height="19px" src="/public/images/github.png"/>
				</a>
			</li>
			<li>
				<a href="/feed.xml" title="RSS">
					<img width="19px" height="19px" src="/public/images/rss.png"/>
				</a>
			</li>
			<li>
				<a href="https://twitter.com/SusanPotter" title="Twitter">
					<img width="19px" height="19px" src="/public/images/twitter.png"/>
				</a>
			</li>
		</ul>
	</div>
</header>

    <br>
    <div class="page-content">
      <div class="wrapper">
        <article class="single row gutters">
  <time class="published" datetime="2015-10-09">09 October 2015</time>
  <h2>Why Use Types?</h2>

  <p>Types are one of the most mainstream and widespread applied formal methods<br />
in software engineering industry today. Yet I have met many accomplished and<br />
experienced practitioners in our field who do not know how to effectively use<br />
types, even in lanuages they can leverage well for this.</p>

<p>This tutorial is an attempt to show step by step an iterative approach to<br />
transforming what I would consider an ill-typed API (a form I see very often<br />
in operations or infrastructure code) towards a more type-expressive API<br />
which eleminates a large set of invalid values from ever being constructed in<br />
the first place.</p>

<p>This will be the basis for future tutorials that will follow, putting into<br />
practice more structural typed techniques often used in typed functional<br />
programming. My claim here is that pairing a half decent type system that<br />
can express many valid constructions of values (and eliminate many invalid<br />
constructions) with functional programming principles and abstractions we can<br />
build a solid core of a working library or executable. It will allow us to<br />
reason about our code such that we can extend it in ways we previously thought<br />
unimaginable without much heavy lifting (after the initial plumbing work). We<br />
will start to see evidence for this claim in this tutorial post and subsequent<br />
tutorials will build upon this foundation to supply more evidence as we go<br />
along on our journey.</p>

<h2 id="to-the-cloud-and-beyond">To The Cloud And Beyond</h2>

<p>Let’s start out with a simple example. We need to model VPCs and Subnets in<br />
AWS:</p>

<pre><code class="language-scala">scala&gt; case class Vpc(
     |   cidrBlock: String,
     |   region: String,
     |   dhcpOptionsId: String,
     |   instanceTenancy: String,
     |   isDefault: Boolean)
defined class Vpc

scala&gt; case class Subnet(
     |   cidrBlock: String,
     |   vpcId: String,
     |   availabilityZone: String,
     |   defaultForAz: Boolean,
     |   mapPublicOnLaunch: Boolean)
defined class Subnet
</code></pre>

<p>Now let’s use these definition to construct values:</p>

<pre><code class="language-scala">scala&gt; val region = "us-west-14"
region: String = us-west-14

scala&gt; val vpc = Vpc("10.0.0.0/16", region, null, "dedicated", false)
vpc: Vpc = Vpc(10.0.0.0/16,us-west-14,null,dedicated,false)

scala&gt; val subnet = Subnet("10.10.16.0/24", "sg-123456", s"${region}b", false, false)
subnet: Subnet = Subnet(10.10.16.0/24,sg-123456,us-west-14b,false,false)
</code></pre>

<p>There are a few problems in just this simple usage of these simple classes:</p>

<ol>
  <li>There is no region named <code>us-west-14</code> and the derived availability zone<br />
value is also invalid.</li>
  <li>A <code>null</code> was given for <code>dhcpOptionsId</code> argument but the behavior of various<br />
utilities using these types is unknown when this happens as we don’t know<br />
if they will actually handle <code>null</code>’s properly with defensive programming.</li>
  <li>We might have fat fingered the <code>instanceTenancy</code>, this time we didn’t, but<br />
who knows when everything is just of type <code>String</code>.</li>
  <li>We have no idea if the given <code>cidr</code> block arguments to either <code>Vpc</code> or<br />
<code>Subnet</code> are valid since we just expect a <code>String</code> representing a CIDR.</li>
  <li>We have no idea if the string id for DHCP options or VPC are referring to<br />
identifiers of the right kind or not.</li>
</ol>

<p>We started with such a simple API and already have numerous issues with just<br />
using weak types in our data type definitions.</p>

<p>Now let’s toughen up these types.</p>

<pre><code class="language-scala">scala&gt; // We build a sum type (also called coproduct in some literature)
     | // This is a kind of algebraic data type that represents a logical OR
     | sealed trait Region
defined trait Region

scala&gt; case object UsWest1 extends Region
defined object UsWest1

scala&gt; case object UsWest2 extends Region
defined object UsWest2

scala&gt; case object UsEast1 extends Region
defined object UsEast1

scala&gt; case object EuWest1 extends Region
defined object EuWest1

scala&gt; // Another sum type here for zone *inside* of a region
     | sealed trait Zone
defined trait Zone

scala&gt; case object A extends Zone
defined object A

scala&gt; case object B extends Zone
defined object B

scala&gt; case object C extends Zone
defined object C

scala&gt; // This is a product type (a dressed up N-tuple)
     | // This is another kind of algebraic data type representing logical AND
     | case class AvailabilityZone(region: Region, zone: Zone)
defined class AvailabilityZone

scala&gt; // A sum type to represent the notion of instance tenancy, I am sure I am
     | // missing possible data constructors (the case objects/classes that extend
     | // from the base class, in this case +InstanceTenancy+).
     | sealed trait InstanceTenancy
defined trait InstanceTenancy

scala&gt; case object Dedicated extends InstanceTenancy
defined object Dedicated

scala&gt; case object Default extends InstanceTenancy
defined object Default

scala&gt; case class Vpc(
     |   cidrBlock: String,
     |   region: Region,
     |   dhcpOptionsId: Option[String],
     |   instanceTenancy: InstanceTenancy,
     |   isDefault: Boolean)
defined class Vpc

scala&gt; case class Subnet(
     |   cidrBlock: String,
     |   vpcId: String,
     |   availabilityZone: AvailabilityZone,
     |   defaultForAz: Boolean,
     |   mapPublicOnLaunch: Boolean)
defined class Subnet
</code></pre>

<p>Now we have some provisioning logic that picks the appropriate AWS<br />
credentials when using specific regions vs others:</p>

<pre><code class="language-scala">scala&gt; // we are just mocking out this function for now and not *doing* anything yet
     | def provisionVpc(vpc: Vpc): String =
     |   if (vpc.region == "us-west-1") "vpc-123456" else "vpc-654321"
&lt;console&gt;:22: warning: Region and String are unrelated: they will most likely never compare equal
         if (vpc.region == "us-west-1") "vpc-123456" else "vpc-654321"
                        ^
provisionVpc: (vpc: Vpc)String
</code></pre>

<p>Here we have a problem. The <code>==</code> is always false, but shouldn’t it be a<br />
compiler error instead? In Scala, <code>==</code> takes on the same semantics as<br />
the same operator in Java and thus will always compile even when you<br />
are comparing the value of a different type.</p>

<p>Thankfully in libraries like <code>cats</code> or <code>scalaz</code> (we will be using<br />
<code>cats</code> in these examples) we can use a type safe equality operator<br />
like so:</p>

<pre><code class="language-scala">scala&gt; import cats._, cats.std.all._, cats.syntax.all._
import cats._
import cats.std.all._
import cats.syntax.all._

scala&gt; implicit val regionEquality = new Eq[Region] {
     |   def eqv(r1: Region, r2: Region): Boolean = r1 == r2
     | }
regionEquality: cats.Eq[Region] = $anon$1@40ed5a7c
</code></pre>

<p>It may not seem like we have accomplished much here except that when we use<br />
<code>===</code> (the typesafe equality operator) our code will not compile when we<br />
check different types for equality:</p>

<pre><code class="language-scala">scala&gt; // Now reimplement provisionVpc (but this does not compile, which is what we
     | // want!!!)
     | def provisionVpc(vpc: Vpc): String =
     |   if (vpc.region === "us-west-1") "vpc-123456" else "vpc-654321"
&lt;console&gt;:33: error: type mismatch;
 found   : String("us-west-1")
 required: Region
         if (vpc.region === "us-west-1") "vpc-123456" else "vpc-654321"
                            ^
</code></pre>

<p>The following will compile and is exactly what we want in our case:</p>

<pre><code class="language-scala">scala&gt; // Now reimplement provisionVpc where types on either side of === match such
     | // that this now compiles but also the logic behaves as we expect and can
     | // reason about.
     | def provisionVpc(vpc: Vpc): String =
     |   if (vpc.region === UsWest1) "vpc-123456" else "vpc-654321"
provisionVpc: (vpc: Vpc)String
</code></pre>

<p>Now we could still improve the constituent types of the <code>Vpc</code> and <code>Subnet</code><br />
product types further such as accepting a <code>Cidr</code> type for the CIDR block<br />
given:</p>

<pre><code class="language-scala">scala&gt; import spire.math._, spire.implicits._
import spire.math._
import spire.implicits._

scala&gt; // Note: UByte is from spire. It is the most natural type that represents
     | // what we want below without defining a low level type ourselves.
     | // Let me know if I missed something from the standard library that isn't
     | // Byte.
     | 
     | sealed trait IpAddress
defined trait IpAddress

scala&gt; object IpAddress {
     |   private case class Ipv4(a: UByte, b: UByte, c: UByte, d: UByte) extends IpAddress
     |   // TODO: implement Ipv6 when needed
     | 
     |   def apply(a: UByte, b: UByte, c: UByte, d: UByte): IpAddress =
     |     Ipv4(a, b, c, d)
     | }
defined object IpAddress
warning: previously defined trait IpAddress is not a companion to object IpAddress.
Companions must be defined together; you may wish to use :paste mode for this.

scala&gt; // We want an unsigned byte to represent the Prefix (at least for now)
     | type Prefix = UByte
defined type alias Prefix

scala&gt; def prefix(p: UByte): Option[Prefix] =
     |   if (p &lt;= UByte(32) &amp;&amp; p &gt;= UByte(0)) Some(p) else None
prefix: (p: spire.math.UByte)Option[Prefix]

scala&gt; case class Cidr(ip: IpAddress, prefix: Prefix)
defined class Cidr
</code></pre>

<p>So far we have addressed 1 through 4 of the list of problems we identified<br />
above. Let’s recap what we did:</p>

<ol>
  <li>We encoded the notion of region as a sum type and changed the type used<br />
from <code>String</code> to <code>Region</code>. We have eliminated a large number of possible<br />
invalid values from being used in it’s place such that non-existent AWS<br />
regions referenced would not even compile.</li>
  <li>We encoded in our type signature for the <code>Vpc</code> product type (case class)<br />
that we do not require DHCP options identifier to construct a valid <code>Vpc</code><br />
value. This will inform implementers of functions that use this value that<br />
this field is an optional value so they can plan accordingly.</li>
  <li>We encoded the notion of instance tenancy as a sum type and switched from<br />
using a <code>String</code> to represent the possible values of it to this new type,<br />
<code>InstanceTenancy</code>. The compiler will not catch any fat fingering we may<br />
have made. Think of the potential troubleshooting and debugging time we<br />
gained back from this simple act.</li>
  <li>We have encoded a more meaningful representation for CIDR values that will<br />
limit the possible values to valid basic constructions. A <code>String</code> value<br />
gives us know structure to verify and the validation logic on a <code>String</code><br />
value for the CIDR case would be error prone and complex without decomposing<br />
into the structural elements of the value in the first place. Even using<br />
regular expressions to validate a <code>String</code> representing a CIDR requires us<br />
to decompose the value into its elements (plus it might not be very<br />
efficient but that is a secondary concern). :)</li>
</ol>

<p>Now we can tackle referential consistency of our string ids via a construct<br />
in Scala called value classes. This allows us to enforce type safety at<br />
compile-time without the runtime allocation overhead.</p>

<p>For our purposes we will wrap up <code>String</code> identifiers designating what kind<br />
of identifier it refers to. As an example whenever we provision or query VPCs<br />
we can wrap the basic string identifier that AWS returns back as a specific<br />
type <code>VpcId</code>. This will not allocate a boxed value but will uniquely identify<br />
the type of <code>String</code> at compile-time.</p>

<pre><code class="language-scala">scala&gt; class VpcId (private val id: String) extends AnyVal
defined class VpcId

scala&gt; class DhcpOptionsId private (val id: String) extends AnyVal
defined class DhcpOptionsId

scala&gt; case class Vpc(
     |   cidrBlock: String,
     |   region: Region,
     |   dhcpOptionsId: Option[DhcpOptionsId],
     |   instanceTenancy: InstanceTenancy,
     |   isDefault: Boolean)
defined class Vpc

scala&gt; case class Subnet(
     |   cidrBlock: String,
     |   vpcId: VpcId,
     |   availabilityZone: AvailabilityZone,
     |   defaultForAz: Boolean,
     |   mapPublicOnLaunch: Boolean)
defined class Subnet
</code></pre>

<p>We also need to make sure the functions provisioning or querying and returning<br />
these identifiers return the appropriate wrapper values.</p>

<pre><code class="language-scala">scala&gt; // Note we are returning VpcId not String any more
     | def provisionVpc(vpc: Vpc): VpcId = ???
provisionVpc: (vpc: Vpc)VpcId

scala&gt; def defaultDhcpOptions(region: Region): DhcpOptionsId = ???
defaultDhcpOptions: (region: Region)DhcpOptionsId
</code></pre>

<p>Now we will be able to see from the type signature something is amiss if we<br />
are returning a <code>VpcId</code> from a function named <code>defaultDhcpOptions</code>. Obviously<br />
that isn’t the level of sanity checking we are aiming for, but it’s a reason-<br />
able start for this session.</p>

<p>You’ll note that we haven’t addressed the problem (yet) that we can simply<br />
construct invalid <code>VpcId</code> values by passing in illegal format of <code>String</code><br />
value to the value class constructor. This will be addressed by a couple of<br />
different techniques in future tutorials. Just know that we will be returning<br />
to this. Promise. :)</p>

<p>We could also replace the type alias for <code>Prefix</code> with a value class:</p>

<pre><code class="language-scala">scala&gt; class Prefix (val b: Byte) extends AnyVal
defined class Prefix

scala&gt; object Prefix {
     |   private def isValid(b: UByte): Boolean =
     |     (b &lt;= UByte(32) &amp;&amp; b &gt;= UByte(0))
     | 
     |   def apply(b: UByte): Option[Prefix] =
     |     if (isValid(b)) Some(new Prefix(b.toByte)) else None
     | }
defined object Prefix
warning: previously defined class Prefix is not a companion to object Prefix.
Companions must be defined together; you may wish to use :paste mode for this.
</code></pre>

<p>The purpose of this initial tutorial was to introduce the reader to the<br />
utility of types generally and specifically how to start to make your APIs<br />
more type safe in Scala using non-structural techniques.</p>

<p>Hopefully we can take away a sense of purpose in types. They don’t have to be<br />
source code annotations that just add more code bloat, they can add<br />
enormous <em>value</em> (yes, I couldn’t resist the pun). You might also have noted<br />
that we have gone quite far with types, yet we can still do more to limit<br />
the values we construt in our code to be only valid ones. How far can we take<br />
this? How far makes sense? Keep these questions in mind.</p>

<p>The next tutorial in the series will walk through how we add some structure<br />
to our types with accompanying functions with specific properties we can<br />
use to reason about our code in more abstract ways.</p>

</article>

      </div>
    </div>
    
    <footer class="footer">
	@2015 Susan Potter.
</footer>

    
  </body>

</html>
